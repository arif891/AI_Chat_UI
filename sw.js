(()=>{var l=class{constructor(e,t=1){this.dbName=e,this.version=t,this.db=null,this.stores=new Map}async connect(){return this.db?this.db:new Promise((e,t)=>{let s=indexedDB.open(this.dbName,this.version);s.onerror=()=>{t(new Error(`Failed to open database: ${s.error}`))},s.onsuccess=()=>{this.db=s.result,e(this.db)},s.onupgradeneeded=r=>{this.db=r.target.result,this.stores.forEach((n,a)=>{this.db.objectStoreNames.contains(a)||this.db.createObjectStore(a,n)})}})}addStore(e,t={keyPath:"id"}){return this.stores.set(e,t),this}async transaction(e,t="readonly"){return this.db||await this.connect(),new Promise((s,r)=>{try{let n=this.db.transaction(e,t),a=n.objectStore(e);n.onerror=()=>{r(new Error(`Transaction failed: ${n.error}`))},s(a)}catch(n){r(new Error(`Failed to start transaction: ${n.message}`))}})}async add(e,t){let s=await this.transaction(e,"readwrite");return new Promise((r,n)=>{let a=s.add(t);a.onsuccess=()=>r(a.result),a.onerror=()=>n(a.error)})}async put(e,t){let s=await this.transaction(e,"readwrite");return new Promise((r,n)=>{let a=s.put(t);a.onsuccess=()=>r(a.result),a.onerror=()=>n(a.error)})}async putBulk(e,t){let s=await this.transaction(e,"readwrite");return Promise.all(t.map(r=>new Promise((n,a)=>{let i=s.put(r);i.onsuccess=()=>n(i.result),i.onerror=()=>a(i.error)})))}async get(e,t){let s=await this.transaction(e);return new Promise((r,n)=>{let a=s.get(t);a.onsuccess=()=>r(a.result),a.onerror=()=>n(a.error)})}async getAll(e,t=null,s=0){let r=await this.transaction(e);return new Promise((n,a)=>{let i=r.getAll(t,s);i.onsuccess=()=>n(i.result),i.onerror=()=>a(i.error)})}async deleteRecord(e,t){let s=await this.transaction(e,"readwrite");return new Promise((r,n)=>{let a=s.delete(t);a.onsuccess=()=>r(),a.onerror=()=>n(a.error)})}async clear(e){let t=await this.transaction(e,"readwrite");return new Promise((s,r)=>{let n=t.clear();n.onsuccess=()=>s(),n.onerror=()=>r(n.error)})}async count(e,t=null){let s=await this.transaction(e);return new Promise((r,n)=>{let a=s.count(t);a.onsuccess=()=>r(a.result),a.onerror=()=>n(a.error)})}async iterate(e,t,s=null){let r=await this.transaction(e);return new Promise((n,a)=>{let i=r.openCursor(s);i.onsuccess=()=>{let c=i.result;c?(t(c.value,c.key),c.continue()):n()},i.onerror=()=>a(i.error)})}async close(){this.db&&(this.db.close(),this.db=null)}async deleteDatabase(){return await this.close(),new Promise((e,t)=>{let s=indexedDB.deleteDatabase(this.dbName);s.onsuccess=()=>e(),s.onerror=()=>t(s.error)})}};function m(o,e){try{return new RegExp(e.replace("*",".*")).test(o)}catch{return!1}}function w(o,e){try{return o.test(e)}catch{return!1}}function h(o){try{let e=o.headers.get("sw-cache-metadata");return e?JSON.parse(e):null}catch{return null}}function y(o){let e=o.headers.get("content-length");return e?parseInt(e,10):0}function b(o,e){return new Response(o.body,{...o,headers:new Headers({...Object.fromEntries(o.headers),"sw-cache-metadata":JSON.stringify(e)})})}function x(o,e){let t=new Headers(o);return e&&t.set("If-Modified-Since",new Date(e).toUTCString()),t}function v(o,e){return new Request(o.url,{method:o.method,headers:e,mode:o.mode,credentials:o.credentials,redirect:o.redirect})}var u=class{constructor(e,t){this.config=e,this.logger=t,this.caches=new Map,this.lastCleanup=new Map,this.cleanupInterval=5*60*1e3,this.batchSize=50,this.versionDB=new l("sw-cache-store",1).addStore("versions",{keyPath:"name",indexes:[{name:"timestamp",keyPath:"timestamp"},{name:"version",keyPath:"version"}]}),this.init()}async init(){try{await this.versionDB.connect(),await this.initializeCaches()}catch(e){this.logger.error("Failed to initialize CacheManager:",e)}}async initializeCaches(){for(let[e,t]of Object.entries(this.config)){if(!t.name||!t.version)continue;let s=this.getVersionedCacheName(e);this.caches.set(e,await caches.open(s)),this.logger.debug(`Initialized cache: ${s}`)}}async precache(){let{offline:e}=this.config;if(e?.urls?.length)try{let t=await caches.open("offline");if(!t)return;let r=(await Promise.allSettled(e.urls.map(async n=>{try{let a=await fetch(n);if(!a.ok)throw new Error(`HTTP error! status: ${a.status}`);await t.put(n,a),this.logger.debug(`Precached: ${n}`)}catch(a){this.logger.error(`Failed to precache ${n}:`,a)}}))).filter(n=>n.status==="rejected").length;r>0&&this.logger.warn(`Failed to precache ${r} resources`)}catch(t){this.logger.error("Precache failed:",t)}}async cleanup(){try{let e=await caches.keys(),t=await this.getStoredVersions(),s=this.getCurrentVersions(),r=[];for(let[a,i]of Object.entries(s)){let c=t[a];if(c&&c!==i){let p=`${a}-v${c}`;e.includes(p)&&r.push(caches.delete(p).then(()=>this.logger.debug(`Deleted outdated cache: ${p}`)))}}let n=new Set(Object.entries(this.config).map(([a,i])=>`${i.name}-v${i.version}`));e.forEach(a=>{n.has(a)||r.push(caches.delete(a).then(()=>this.logger.debug(`Deleted unrecognized cache: ${a}`)))}),await Promise.all(r),await this.storeVersions(s),await this.initializeCaches()}catch(e){this.logger.error("Cache cleanup failed:",e)}}async getStoredVersions(){try{return(await this.versionDB.getAll("versions")).reduce((t,{name:s,version:r})=>(t[s]=r,t),{})}catch{return{}}}getCurrentVersions(){return Object.entries(this.config).reduce((e,[t,s])=>(e[t]=s.version,e),{})}async storeVersions(e){try{let t=Date.now(),s=Object.entries(e).map(([r,n])=>({name:r,version:n,timestamp:t}));try{await this.versionDB.putBulk("versions",s)}catch{await Promise.all(s.map(r=>this.versionDB.put("versions",r)))}}catch(t){this.logger.error("Failed to store cache versions:",t)}}async get(e,t){try{let s=await caches.open(this.getVersionedCacheName(t)),r=await s.match(e);if(!r)return null;let n=this.getCacheConfig(t);return!n||this.isResponseValid(r,n)?r:(await s.delete(e),null)}catch(s){return this.logger.error(`Failed to get cached response for ${e.url}:`,s),null}}async put(e,t,s){try{let r=await caches.open(this.getVersionedCacheName(s));if(!t.ok){this.logger.warn(`Skipping cache for non-ok response: ${e.url}`);return}let n={timestamp:Date.now(),size:y(t),url:e.url,type:e.destination},a=b(t,n);await r.put(e,a),this.checkCleanupNeeded(s),this.logger.debug(`Cached ${e.url} in ${s}`)}catch(r){this.logger.error(`Failed to cache ${e.url}:`,r)}}async checkCleanupNeeded(e){let t=this.lastCleanup.get(e)||0,s=Date.now();s-t>=this.cleanupInterval&&(this.scheduleCacheCleanup(e),this.lastCleanup.set(e,s))}scheduleCacheCleanup(e){setTimeout(async()=>{try{await this.cleanupCache(e)}catch(t){this.logger.error(`Scheduled cleanup failed for ${e}:`,t)}},0)}async cleanupCache(e){let t=await caches.open(this.getVersionedCacheName(e)),s=this.getCacheConfig(e);if(s)try{let r=await t.keys(),n=r.length;this.needsSizeCleanup(s,n)&&await this.batchCleanup(t,r,s)}catch(r){this.logger.error(`Cache cleanup failed for ${e}:`,r)}}needsSizeCleanup(e,t){return e.maxItems&&t>e.maxItems*1.2||e.maxSize&&t>this.batchSize}async batchCleanup(e,t,s){let r=0,n=[];for(let a=0;a<t.length;a+=this.batchSize){let i=t.slice(a,a+this.batchSize),c=await this.processBatch(e,i,s);if(r+=c.size,n=n.concat(c.entries),this.shouldRemoveEntries(s,n.length,r)){await this.removeOldestEntries(e,n,s);break}}}async processBatch(e,t,s){let r=0,n=[];for(let a of t){let i=await e.match(a);if(!i)continue;let c=h(i);c&&(n.push({request:a,timestamp:c.timestamp,size:c.size||0}),r+=c.size||0)}return{size:r,entries:n}}shouldRemoveEntries(e,t,s){return e.maxItems&&t>e.maxItems||e.maxSize&&s>e.maxSize}async removeOldestEntries(e,t,s){t.sort((a,i)=>a.timestamp-i.timestamp);let r=0,n=0;for(;t.length>0&&this.shouldRemoveEntries(s,t.length-r,t.reduce((a,i)=>a+i.size,0)-n);){let a=t.shift();await e.delete(a.request),r++,n+=a.size,this.logger.debug(`Removed old cache entry: ${a.request.url}`)}}getVersionedCacheName(e){let t=this.getCacheConfig(e);return t?`${t.name}-v${t.version}`:e}isExcluded(e,t){return t.exclude?!!(t.exclude.urls?.some(s=>e.url.includes(s))||t.exclude.types?.includes(e.destination)||t.exclude.patterns?.some(s=>s.test(e.url))):!1}getCacheConfig(e){let t=Object.entries(this.config).find(([s,r])=>r.name===e);return t?t[1]:null}isResponseValid(e,t){if(!t?.maxAge)return!0;let s=h(e);if(!s?.timestamp)return!0;let r=Date.now()-s.timestamp,n=r<t.maxAge;return n||this.logger.debug(`Cache entry expired: ${e.url}, age: ${r}ms`),n}async enforceLimit(e,t){if(t)try{let s=await e.keys();if(t.maxItems&&typeof t.maxItems=="number")for(;s.length>=t.maxItems;){let r=s.shift();r&&(await e.delete(r),this.logger.debug(`Removed old cache entry: ${r.url}`))}if(t.maxSize&&typeof t.maxSize=="number"){let r=0;for(let n of s){let a=await e.match(n);if(!a)continue;let i=h(a);i?.size&&(r+=i.size,r>t.maxSize&&(await e.delete(n),this.logger.debug(`Removed cache entry due to size limit: ${n.url}`)))}}}catch(s){this.logger.error("Error enforcing cache limits:",s)}}getResponseMetadata(e){return h(e)}getResponseSize(e){let t=e.headers.get("content-length");return t?parseInt(t,10):0}};var d=class{constructor(e,t,s){this.cache=e,this.config=t,this.logger=s}async handleApi(e){let t=this.config.api.cacheStrategy;return this[t](e)}async handleAsset(e){let t=e.request;try{return this.isStaticAsset(t)?await this.cacheFirst(e):this.isExcluded(t,this.config.caches.runtime)||this.config.caches.runtime?.enabled===!1?await this.fetch(e):await this.networkFirst(e)}catch(s){return this.logger.error("Asset handling failed:",s),await this.getFallback(t)}}async networkFirst(e){try{let t=await this.fetch(e);return t.ok&&e.waitUntil(this.cache.put(e.request,t.clone(),"runtime")),t}catch(t){this.logger.warn("Network request failed, falling back to cache");let s=await this.cache.get(e.request,"runtime");if(s)return s;throw t}}async cacheFirst(e,t=!1){let s=await this.cache.get(e.request,"static");if(s)return t&&e.waitUntil(this.revalidate(e.request,s.clone())),s;try{let r=await this.fetch(e);return r.ok&&e.waitUntil(this.cache.put(e.request,r.clone(),"static")),r}catch(r){throw this.logger.error("Cache-first fetch failed:",r),r}}async fetch(e){try{let t=await e.preloadResponse;if(t)return this.logger.debug("Using preloaded response"),t;let s=await fetch(e.request);if(!s)throw new Error("Fetch returned empty response");return s}catch(t){throw this.logger.error("Fetch failed:",t),t}}async revalidate(e,t){try{let s=this.cache.getResponseMetadata(t),r=x(e.headers,s?.timestamp),n=v(e,r),a=await fetch(n);a.ok&&a.status!==304&&(await this.cache.put(e,a,"static"),this.logger.debug("Background revalidation updated cache"))}catch(s){this.logger.error("Background revalidation failed:",s)}}async getFallback(e){try{if(e.destination==="image")return this.cache.get(this.config.fallback.image);if(e.destination==="document")return this.cache.get(this.config.fallback.document)}catch(t){throw t}return new Response("Resource unavailable offline",{status:503})}isStaticAsset(e){let t=this.config.caches.static?.urls||[],s=this.config.caches.offline?.urls||[],r=[...t,...s],n=this.config.caches.static?.types||[],a=r.some(c=>m(e.url,c)),i=n.includes(e.destination);return a||i}isExcluded(e,t){if(!t?.exclude)return!1;let{urls:s=[],types:r=[],patterns:n=[]}=t.exclude;return s.some(a=>m(e.url,a))||r.includes(e.destination)||n.some(a=>w(a,e.url))}};var g={version:"1.0.0",navigationPreload:!0,debug:{enabled:!1,level:"debug",logToServer:!1,serverEndpoint:"/api/logs"},caches:{offline:{name:"offline-cache",version:1,urls:["/assets/css/base.css","/assets/css/pages/chat_app.css","/assets/js/base.js","/assets/js/pages/chat_app.js"],priority:"reliability"},static:{name:"static-cache",version:1,urls:["/pages/static/*","/assets/static/*"],types:["image","font"],maxAge:2592e6,maxItems:100,maxSize:104857600,priority:"speed",exclude:{urls:["/api/*","/dynamic/*"],types:["video","audio"],patterns:[/\.(php|aspx)$/]}},runtime:{enabled:!0,name:"runtime-cache",version:1,exclude:{types:["video","audio"]},maxItems:200,maxAge:2592e5,maxSize:524288e3,priority:"balance",cleanupStrategy:"lru"}},api:{endpoints:["/api/*"],version:"v1",cacheStrategy:"network-first",timeout:5e3,retryAttempts:3,retryDelay:1e3,errorHandling:{retry4xx:!1,retry5xx:!0,retryTimeout:!0,fallbackToCache:!0},headers:{"X-API-Version":"v1","X-Client-Type":"pwa"}}};var f=class{constructor(){this.cache=new u(g.caches,console),this.requestHandler=new d(this.cache,g,console),this.init()}init(){self.addEventListener("install",e=>this.handleInstall(e)),self.addEventListener("activate",e=>this.handleActivate(e)),self.addEventListener("fetch",e=>this.handleFetch(e))}async handleInstall(e){console.log("Installing Service Worker..."),e.waitUntil(Promise.all([this.cache.precache(e),self.skipWaiting()]))}async handleActivate(e){console.log("Activating Service Worker..."),e.waitUntil(Promise.all([this.cache.cleanup(),self.clients.claim(),this.enableNavigationPreload()]))}async handleFetch(e){let t=e.request;try{if(this.isApiRequest(t)){e.respondWith(this.requestHandler.handleApi(e));return}e.respondWith(this.requestHandler.handleAsset(e))}catch(s){console.error("Fetch handling failed:",s),e.respondWith(Response.error())}}isApiRequest(e){return g.api.endpoints.some(t=>e.url.includes(t.replace("*","")))}async enableNavigationPreload(){self.registration.navigationPreload&&await self.registration.navigationPreload.enable()}};try{let o=new f;self.__SW__=o}catch(o){console.error("Failed to initialize Service Worker:",o)}})();
